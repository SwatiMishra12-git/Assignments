# -*- coding: utf-8 -*-
"""Assignment1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TMv_AK7Q3HneX-aDe_fxirL4L83mXvpM

# ***Q1. Explain the key features of python that make it a popular choice for programming.***

Ans.Python is a powerful programming language due to the following key features:

**a)Simple and Readable Syntax:**Python's syntax is clear and concise, making it easy to read and write. This helps reduce the learning curve for beginners and increases productivity for experienced developers.

**b)Interpreted Language:**Python is an interpreted language, which means code is executed line by line. This facilitates easier debugging and quick testing of small code snippets.

**c)Dynamically Typed:**Python uses dynamic typing, allowing developers to write more flexible and less verbose code. Variable types are determined at runtime, which simplifies coding and reduces boilerplate.

**d)Extensive Standard Library:**Python's standard library is vast and comprehensive, providing modules and functions for a wide range of tasks, from file I/O and system calls to web development and data manipulation.

**e)Cross-Platform Compatibility:**Python is platform-independent, meaning it can run on various operating systems such as Windows, macOS, and Linux with little or no modification to the code.

# ***2. Describe the role of predefined keywords in Python and provide examples of how they are used in a program.***

Ans.Predefined keywords in Python, also known as reserved words, are the fundamental building blocks of the language. They have specific meanings and purposes, defining the syntax and structure of the Python language. These keywords are used to write statements, expressions, and control the flow of the program. As they are reserved, they cannot be used as identifiers (i.e., variable names, function names, or any other identifiers).

Here are some examples of predefined keywords in Python and their roles:

**Control Flow Keywords**

if, elif, else: Used for conditional branching.
for, while, break, continue: Used for loops and controlling loop execution.
try, except, finally, raise: Used for exception handling.

**Function and Class Definition Keywords:**

def: Used to define a function.
return: Used to return a value from a function.
class: Used to define a class.
pass: Used as a placeholder for a block of code that is not implemented yet.

**Variable Scope Keywords:**

global: Used to declare a global variable.

nonlocal: Used to declare a non-local variable in nested functions.

**Logical and Boolean Keywords:**

and, or, not: Used for logical operations.
True, False: Boolean values.

The use of predefined keywords using code snippets are as follows:
"""

#Conditional Statements
x = 16
if x >10:
    print("x is greater than 10")
elif x == 10:
    print("x is equal to 10")
else:
    print("x is less than 10")

#Loops
for i in range(5):
    if i == 3:
        break
    print(i)

i = 0
while i < 5:
    if i == 3:
        i += 1
        continue
    print(i)
    i += 1

#Logical Operations
a = True
b = False

if a and not b:
    print("a is True and b is False")

if a or b:
    print("Either a or b is True")

"""# ***3. Compare and contrast mutable and immutable objects in Python with examples.***

---


Ans. In Python, objects can be classified as either mutable or immutable based on whether their state (i.e., data/content) can be changed after they are created

**Immutable Objects**

Immutable objects are objects whose state cannot be modified after they are created. Any attempt to change the content of an immutable object results in the creation of a new object. Examples of immutable objects in Python include:


*   Integers, Floats, Strings,Tuples, Booleans





"""

#Integers
x = 5
y = x
x += 2  # x now refers to a new integer object 7
print(x)  # Output: 7
print(y)  # Output: 5 (y still refers to the original object 5)

#Strings
str1 = "hello"
str2 = str1
str1 += " world"  # str1 now refers to a new string object "hello world"
print(str1)  # Output: "hello world"
print(str2)  # Output: "hello" (str2 still refers to the original string "hello")

#Tuples
tup1 = (1, 2, 3)
tup2 = tup1
# Tuples are immutable, so we can't change their contents directly
# tup1[0] = 10  # This would raise a TypeError
tup1 = (4, 5, 6)  # tup1 now refers to a new tuple (4, 5, 6)
print(tup1)  # Output: (4, 5, 6)
print(tup2)  # Output: (1, 2, 3) (tup2 still refers to the original tuple)

"""**Mutable Objects**

Mutable objects are objects whose state can be modified after they are created. This means that their content can be changed without creating a new object. Examples of mutable objects in Python include:

Lists,
Dictionaries,
Sets,
User-defined classes (by default).
"""

#List
list1 = [1, 2, 3]
list2 = list1
list1.append(4)  # Modifies the content of the existing list object
print(list1)  # Output: [1, 2, 3, 4]
print(list2)  # Output: [1, 2, 3, 4] (list2 refers to the same object as list1)

#Dictionaries
dict1 = {'a': 1, 'b': 2}
dict2 = dict1
dict1['c'] = 3  # Modifies the content of the existing dictionary object
print(dict1)  # Output: {'a': 1, 'b': 2, 'c': 3}
print(dict2)  # Output: {'a': 1, 'b': 2, 'c': 3} (dict2 refers to the same object as dict1)

#Set
set1 = {1, 2, 3}
set2 = set1
set1.add(4)  # Modifies the content of the existing set object
print(set1)  # Output: {1, 2, 3, 4}
print(set2)  # Output: {1, 2, 3, 4} (set2 refers to the same object as set1)

"""**Key Differences**

**State Modification**:

Immutable: The state cannot be modified after creation. Any modification
results in a new object.

Mutable: The state can be modified after creation without creating a new object.

**Memory Efficiency:**

Immutable: Since new objects are created for modifications, it may lead to higher memory usage.

Mutable: Modifications are made in place, potentially using less memory.

**Thread Safety:**

Immutable: Generally thread-safe because their state cannot change.

Mutable: Not inherently thread-safe, as their state can change.

**Hashability:**

Immutable: Immutable objects like strings and tuples are hashable and can be used as keys in dictionaries or elements in sets.

Mutable: Mutable objects like lists and dictionaries are not hashable and cannot be used as keys in dictionaries or elements in sets.

# ***4.Discuss the different types of operators in Python and provide examples of how they are used.***

Ans. Python supports a variety of operators, which are special symbols used to perform operations on variables and values. These operators can be classified into several categories:

**1. Arithmetic Operators**
Arithmetic operators are used to perform basic mathematical operations such as addition, subtraction, multiplication, etc.
"""

#Addition
a = 10
b = 5
print(a + b)  # Output: 15

#Subtraction
print(a - b)  # Output: 5

#Multiplication
print(a * b)

#Division
print(a / b)

"""**2. Comparison Operators**
Comparison operators are used to compare two values and return a boolean result (True or False).
"""

#Equal
print(a == b)

#Not Equal
print(a != b)  # Output: True

#Greater Than
print(a > b)  # Output: True

"""**3. Logical Operators**
Logical operators are used to combine conditional statements.
"""

x = True
y = False
#AND
print(x and y)  # Output: False
#OR
print(x or y)  # Output: True
#NOT
print(not x)  # Output: False

"""**4. Bitwise Operators**
Bitwise operators are used to perform bit-level operations.



"""

#AND
a = 10  # Binary: 1010
b = 4   # Binary: 0100
print(a & b)  # Output: 0 (Binary: 0000)
#OR
print(a | b)  # Output: 14 (Binary: 1110)
#XOR
print(a ^ b)  # Output: 14 (Binary: 1110)

"""**5.Membership Operators**
Membership operators are used to test if a sequence contains a specified item.
"""

#In
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)  # Output: True
#Not in
print(6 not in my_list)  # Output: True

"""**6.Identity Operators**
Identity operators are used to compare the memory locations of two objects.
"""

#Is
x = ["apple", "banana"]
y = ["apple", "banana"]
z = x
print(x is z)  # Output: True
print(x is y)  # Output: False
#Is not
print(x is not y)  # Output: True

"""# ***5.Explain the concept of typecasting in Python with examples.***

Ans. Typecasting, also known as type conversion, is the process of converting one data type to another. In Python, this can be done in two ways: implicit type conversion (automatic) and explicit type conversion (manual).

## Implicit Type Conversion
In implicit type conversion, Python automatically converts one data type to another without any explicit instruction from the user. This usually happens in mixed-type expressions where the conversion ensures that the operation is performed correctly.
"""

# Implicit conversion from integer to float
a = 5
b = 3.2
result = a + b
print(result)        # Output: 8.2
print(type(result))  # Output: <class 'float'>

"""In this example, a is an integer and b is a float. When we add them together, Python implicitly converts a to a float before performing the addition.

## Explicit Type Conversion

"""

#Converting Integer to Float
a = 5
b = float(a)
print(b)  # Output: 5.0
print(type(b))  # Output: <class 'float'>

#Converting Float to Integer
c = 3.2
d = int(c)
print(d)  # Output: 3
print(type(d))  # Output: <class 'int'>

#Converting String to Integer
e = "123"
f = int(e)
print(f)  # Output: 123
print(type(f))  # Output: <class 'int'>

#Converting String to Float
g = "3.14"
h = float(g)
print(h)  # Output: 3.14
print(type(h))  # Output: <class 'float'>

#Converting List to Tuple
i = [1, 2, 3]
j = tuple(i)
print(j)  # Output: (1, 2, 3)
print(type(j))  # Output: <class 'tuple'>

"""Typecasting is a powerful tool in Python that allows developers to convert data types to fit the needs of their programs, ensuring proper operations and manipulations.

# ***6. How do conditional statements work in Python? Illustrate with examples.***

Ans. Conditional statements in Python allow the execution of certain blocks of code based on whether a condition is true or false. These statements help control the flow of a program by making decisions. The main conditional statements in Python are if, elif, and else

**if Statement**

The if statement is used to test a condition. If the condition evaluates to True, the block of code inside the if statement is executed

**elif Statement**

The elif (short for else if) statement is used to test multiple conditions. It comes after the if statement and before the else statement, if present. If the if condition is false, the elif condition is checked.

**else Statement**

The else statement is used to execute a block of code when none of the conditions are true. It comes at the end of the conditional statements.
"""

#if statement
x = 10
if x > 5:
    print("x is greater than 5")

#elif statement
if x > 10:
    print("x is greater than 10")
elif x < 5:
    print("x is less than 5")
else:
    print("x is between 5 and 10")

"""**Nested Conditional Statements**

Conditional statements can be nested, which means you can have an if, elif, or else block inside another if, elif, or else block.
"""

#Nested conditional statements
age = 20
gender = "female"

if age >= 18:
    if gender == "female":
        print("You are an adult woman.")
    else:
        print("You are an adult man.")
else:
    if gender == "female":
        print("You are a girl.")
    else:
        print("You are a boy.")

"""# ***7.Describe the different types of loops in Python and their use cases with examples.***

Ans.In Python, loops are used to execute a block of code repeatedly as long as a condition is met. Python supports two main types of loops: for loops and while loops. Additionally, Python provides control statements like break, continue, and else within loops to control the flow of the loop execution.

**1. For Loop**

The for loop is used to iterate over a sequence (such as a list, tuple, dictionary, set, or string). It is particularly useful when the number of iterations is known beforehand.

Use Case: Iterating over elements in a list.

**2. While Loop**
The while loop repeats a block of code as long as a condition is true. It is useful when the number of iterations is not known and depends on a condition.

Use Case: Reading user input until a specific condition is met.

**3. Nested Loops**
Nested loops are loops within loops. The inner loop runs completely every time the outer loop runs once. They are useful for working with multi-dimensional data structures, such as matrices.

Use Case: Printing elements of a 2D list (matrix).
"""

# Iterating over a list
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    print(num)

#while loop
count = 0
while count < 5:
    print(count)
    count += 1

#nested loops
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
for row in matrix:
    for element in row:
        print(element)